#!/usr/bin/python3
# Poison Cloud HTTP service

from http.server import BaseHTTPRequestHandler, HTTPServer
from http import HTTPStatus
from typing import Optional
from urllib.parse import urlparse
import functools
import argparse
import pathlib
import json
import time
import os


__version__ = "0.2"
START_TIME = time.time()
API_VERSION = 1


def load_file(path: str) -> Optional[str]:
    """Read the whole file at `path` and return the contents or None."""
    if not os.path.exists(path):
        return
    with open(path, "r") as f:
        return f.read()


def log(*args):
    """Print a message with a timestamp to stdout."""

    msg = " ".join(str(x) for x in args)
    dt = time.time() - START_TIME
    print(f"[{dt: 8.2f}] {msg}")


def json_bytes(blob) -> bytes:
    """Turn a JSON blob into a bytes."""
    return bytes(json.dumps(blob), "utf8")


class User:
    """Represents a single user."""

    def __init__(self, username: str, passwd: str):
        self.username = username
        self.passwd = passwd

    def files_list(self, path: str) -> Optional[dict]:
        """Returns a list of files and directories in a {"files": [ ... ],
        "dirs": [ ... ]} map, otherwise returns None if fails or path is invalid."""

        check_path = pathlib.Path(path)
        if ".." in check_path.parts or "." in check_path.parts:
            return

        path = pathlib.Path(f"files/{self.username}/" + path)
        if not path.is_dir():
            return

        files = []
        dirs = []

        for file in path.iterdir():
            if file.is_dir():
                dirs.append(file.name)
            if file.is_file():
                files.append(file.name)

        return {"files": files, "dirs": dirs}


class Users:
    """Allows access to users."""

    users: dict
    keys: dict

    def __init__(self, userlist_path: str):
        self.userlist_path = userlist_path
        self.users = {}
        self.keys = {"test": "bc2ee117f2fb901fe0af62d2952161aa"}

        userlist = load_file(userlist_path)
        if not userlist:
            return

        users = json.loads(userlist)
        for username, info in users.items():
            self.users[username] = User(username, info["passwd"])

        log(f"Loaded {len(self.users)} user(s)")

    @staticmethod
    def generate_session_key() -> str:
        """Generate a 32-character hex key."""
        key = ""
        with open("/dev/random", "rb") as f:
            bs = f.read(16)
        for b in bs:
            key += f"{hex(b)[2:]:02}"
        return key

    def active_users(self) -> list:
        """Get active user list."""
        return list(self.users.keys())

    def get_user_by_session_key(self, session_key: str) -> User:
        """Returns the user object."""
        for user, key in self.keys.items():
            if key == session_key:
                return self.users[user]

    def is_valid_session_key(self, session_key: str) -> bool:
        """Returns True if the given session_key is correct, and matches
        a currently logged-on user."""
        return session_key in self.keys.values()

    def authenticate(self, username: str, passwd: str) -> Optional[str]:
        """Returns a new session key if user exists and password hash matches."""
        if username in self.users:
            if self.users[username].passwd == passwd:
                self.keys[username] = self.generate_session_key()
                return self.keys[username]
        return

    def logout(self, session_key: str):
        """Log-out the user, based on the session_key."""
        if self.is_valid_session_key(session_key):
            # TODO: remove session key from self.keys
            pass

    def save(self):
        with open(self.userlist_path, "w") as f:
            json.dump(f)


class Service(BaseHTTPRequestHandler):
    """The poisoncloud service."""

    users: Users

    def __init__(self, users, *args, **kwargs):
        self.users = users
        self.endpoints_get = {
            "/": self.get_index,
            "/ping": self.get_ping,
            "/endpoints": self.get_endpoints,
            "/v1/active_users": self.get_active_users,
            "/v1/user_details": self.get_user_details,
            "/v1/files/list": self.get_files_list,
        }

        self.endpoints_post = {
            "/v1/user/login": self.post_user_login,
            "/v1/user/logoff": self.post_user_logoff,
        }

        super().__init__(*args, **kwargs)

    def reply(self, status: int, blob: dict):
        """Generic JSON reply."""

        self.send_response(status)
        self.send_header("Content-Type", "application/json")
        self.send_header("Access-Control-Allow-Origin", "*")
        self.end_headers()

        if not blob:
            blob = {}
        blob["status"] = status

        self.wfile.write(json_bytes(blob))

    def reply_ok(self, blob: dict):
        """Generic JSON reply. The JSON blob will get merged with the status field."""

        self.reply(HTTPStatus.OK, blob)

    def reply_bad_request(self):
        """Send a reply_bad_request response (no such endpoint)."""

        self.send_response(HTTPStatus.BAD_REQUEST)
        self.send_header("Content-Type", "application/json")
        self.end_headers()

        self.wfile.write(
            json_bytes({"status": HTTPStatus.BAD_REQUEST, "error": "no such endpoint"})
        )

    def check_session_key(self) -> Optional[str]:
        """Returns the session key if found in HTTP headers, otherwise returns None."""

        if "Authorization" not in self.headers:
            return

        auth = self.headers["Authorization"]
        if not auth.startswith("Bearer "):
            return

        auth = auth.removeprefix("Bearer ")
        if self.users.is_valid_session_key(auth):
            return auth

    def request_owner(self) -> Optional[User]:
        """Returns the owner of the request, returns None if authorization is missing
        or the session key is invalid."""

        skey = self.check_session_key()
        if not skey:
            return self.reply(
                HTTPStatus.UNAUTHORIZED, {"error": "authentication required"}
            )

        user = self.users.get_user_by_session_key(skey)
        if not user:
            return self.reply(HTTPStatus.FORBIDDEN, {"error": "invalid session key"})

        return user

    def generic_endpoint_handler(self, endpoint_list: dict, *args, **kwargs):
        """Offer a generic endpoint handler."""

        url = urlparse(self.path)
        path = url.path

        if path in endpoint_list:
            if not args:
                endpoint_list[path]()
            else:
                endpoint_list[path](*args, **kwargs)
            return

        self.reply_bad_request()

    # GET handler & endpoints

    def do_GET(self):
        """Handle GET requests."""
        self.generic_endpoint_handler(self.endpoints_get)

    def get_index(self) -> dict:
        """/. Index message."""
        self.reply_ok(
            {
                "message": "see /ping for service information & /endpoints for "
                "a list of endpoints."
            }
        )

    def get_ping(self) -> dict:
        """/ping. Replies with a "pong" message."""
        self.reply_ok(
            {
                "message": "pong",
                "service_name": "poisoncloud",
                "service_version": __version__,
                "api_version": API_VERSION,
            }
        )

    def get_endpoints(self) -> dict:
        """/endpoints. Lists all endpoints."""
        self.reply_ok(
            {
                "GET": list(self.endpoints_get.keys()),
                "POST": list(self.endpoints_post.keys()),
            }
        )

    def get_active_users(self):
        """/v1/active_users. Get a list of active, currently logged on users."""

        if not self.check_session_key():
            return self.reply(
                HTTPStatus.UNAUTHORIZED, {"error": "authentication required"}
            )

        self.reply_ok({"users": self.users.active_users()})

    def get_user_details(self):
        """/v1/user_details. Returns details of the currently logged-in user."""

        if not (user := self.request_owner()):
            return

        return self.reply_ok({"username": user.username, "name": "?"})

    def get_files_list(self):
        """/v1/files/list. List all files in the given directory."""

        if not (user := self.request_owner()):
            return

        files = user.files_list("/")
        if not files:
            return self.reply(HTTPStatus.FORBIDDEN, {"error": "bad path"})

        self.reply_ok(files)

    # POST handler & requests

    def do_POST(self):
        """Handle POST requests."""

        if "Content-Length" not in self.headers:
            return self.reply(
                HTTPStatus.LENGTH_REQUIRED, {"error": "missing Content-Length header"}
            )

        try:
            content = self.rfile.read(int(self.headers["Content-Length"]))
            rq = json.loads(str(content, "utf8"))
        except json.JSONDecodeError:
            return self.reply(
                HTTPStatus.BAD_REQUEST, {"error": "invalid request format"}
            )

        self.generic_endpoint_handler(self.endpoints_post, rq)

    def post_user_login(self, rq: dict):
        """/v1/user/login."""

        res = self.ensure_fields(rq, {"username": str, "passwd": str})
        if not res:
            return self.reply(HTTPStatus.BAD_REQUEST, {"error": "malformed request"})

        session_key = self.users.authenticate(rq["username"], rq["passwd"])
        if not session_key:
            return self.reply(
                HTTPStatus.UNAUTHORIZED, {"error": "bad username or password"}
            )

        return self.reply_ok({"message": "user authorized", "session_key": session_key})

    def post_user_logoff(self, rq: dict):
        """/v1/user/logoff."""

        if not self.check_session_key():
            return self.reply(
                HTTPStatus.UNAUTHORIZED, {"error": "authentication required"}
            )

    @staticmethod
    def ensure_fields(rq: dict, fields: dict) -> bool:
        """Returns true if all fields can be found in the request."""
        for field_name, type_ in fields.items():
            if field_name not in rq:
                return False
            if not isinstance(rq[field_name], type_):
                return False

        return True

    # Non-functional stuff

    def log_message(self, format, *args):
        log(f"\033[90m{format % args}\033[0m")

    def do_OPTIONS(self):
        """Respond to OPTIONS requests."""

        self.send_response(HTTPStatus.OK)
        self.send_header("Allow", "GET, POST, OPTIONS")

        if "Origin" in self.headers:
            self.send_header("Access-Control-Allow-Origin", self.headers["Origin"])

        if "Access-Control-Request-Method" in self.headers:
            self.send_header("Access-Control-Allow-Method", "GET, POST, OPTIONS")

        if "Access-Control-Request-Headers" in self.headers:
            self.send_header(
                "Access-Control-Allow-Headers",
                self.headers["Access-Control-Request-Headers"],
            )

        self.end_headers()

    def do_HEAD(self):
        self.reply_bad_request()

    def do_PUT(self):
        self.reply_bad_request()


def main():
    parser = argparse.ArgumentParser(description="Poison Cloud HTTP service.")
    parser.add_argument(
        "-v", "--version", action="store_true", help="show the version and exit"
    )

    parser.add_argument("host", help="interface IP address to use")
    parser.add_argument("port", type=int, help="port to host on")

    args = parser.parse_args()

    if args.version:
        print(f"poisoncloud {__version__}")
        return

    server_cls = functools.partial(Service, Users("users.json"))
    server = HTTPServer((args.host, args.port), server_cls)
    try:
        log(f"Starting server on {args.host}:{args.port}")
        server.serve_forever()
    except KeyboardInterrupt:
        pass

    server.server_close()


main()
